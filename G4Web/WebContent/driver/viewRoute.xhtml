<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:f="http://java.sun.com/jsf/core"
	xmlns:h="http://java.sun.com/jsf/html"
	xmlns:p="http://primefaces.org/ui">

<h:head>
	<link rel="stylesheet"
		href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" />
	<h:form method="post" id="homeform">
		<h:commandButton value="Home" class="btn btn-primary pull-left"
			action="#{userController.goToIndexD()}"
			style="float: left;text-decoration:none; padding:5px;" />
	</h:form>
	<title><ui:insert name="title">Route view</ui:insert></title>
	<meta name="viewport" content="initial-scale=1.0" />
	<meta charset="utf-8" />
	<style>
.mapinv {
	display: none;
}
/* Always set the map height explicitly to define the size of the div
 * element that contains the map. */
#map {
	height: 100%;
	width: 100%;
}

.mapinv {
	display: none;
}
</style>
	<meta name="viewport" content="initial-scale=1.0" />
	<meta charset="utf-8" />
	<f:metadata>
		<f:viewParam name="route" value="#{routeController.route.id}" />
		<f:viewAction action="#{routeController.findRoute}" />
	</f:metadata>
</h:head>

<h:body>

	<div class="jumbotron jumbotron-sm">
		<div class="container">
			<div class="row">
				<div class="col-sm-12 col-lg-12">

					<h1 class="h1">
						Route to: #{routeController.route.eindpunt} <small></small>
					</h1>

				</div>
			</div>
		</div>
	</div>
	<br />


	<div align='center' class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="well well-sm">
					<div style="margin: 0 auto; width: 600px; height: 600px;" id="map"></div>
					<h2>Laatste aankomsttijd: #{routeController.route.eindtijd}</h2>
					<h2>Aantal vrije zitplaatsen:
						#{routeController.route.maxPersonen}</h2>
					<br />
					<div align='center'>
						<h:outputLabel value="Vertrek Adres: " />
						<input required="required" id="vertrekAdress" type="text" />
						
					</div>
					<br />
					<button onclick="DistanceCalc(), initMap();">Check me</button>
					<div align='center'>
						<h:form method="post" id="requestform">
						<h:inputHidden id="pleaseGodWork" value="#{ritController.rit.beginpunt}" />
						<h:inputHidden id ="VertrekTijd" value="#{ritController.rit.vertrektijd}" />
							<h:commandButton  id="Verzoek" value="Verstuur verzoek" class="btn btn-primary"
								action="#{ritController.requestRit(routeController.route.id)}"
								style="margin: 0 auto;text-decoration:none; padding:5px; display:none" />
						</h:form>
					</div>
				</div>
			</div>
		</div>
	</div>
	<script
		src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAUI3IbCN38MjQJgCJptMXN4NluM7EdHns&amp;libraries=places,geometry&amp;callback=PlaceAutocompleteSearch&amp;fields=formatted_address&amp;callback=initMap"
		async="" defer=""></script>


	<script>

      function initMap() {
        var directionsService = new google.maps.DirectionsService;
        var directionsRenderer = new google.maps.DirectionsRenderer;
        let map = new google.maps.Map(document.getElementById('map'), {
          zoom: 6,
          center: {lat: 51.051410, lng: 3.726115}
        });
        directionsRenderer.setMap(map);
        
		
          markerMap();
          
          calculateAndDisplayRoute(directionsService, directionsRenderer);
          PlaceAutocompleteSearch();
          
          
          
          function markerMap(){
      		var geocoder = new google.maps.Geocoder;
      		geocoder.geocode( { 'address': document.getElementById('requestform:pleaseGodWork').value}, function(results, status) {
      			
      				if (status == 'OK') {
      					var latlng = {lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng()};
      					console.log(latlng);
      			  		 var marker = new google.maps.Marker({
      						    map: map,
      						    position: latlng
      			    		});
      			  		 
      			  		 marker.setMap(map);
      			  		 
      			  		 
      			  		bounds  = new google.maps.LatLngBounds();
      		          loc = new google.maps.LatLng(marker.position.lat(), marker.position.lng());
      		          bounds.extend(loc);
      		          map.fitBounds(bounds);
      		        map.panToBounds(bounds);
      		          console.log("re-zoom");
      			  		 
      			    } else {
      	       alert('Geocode was not successful for the following reason: ' + status);
      				}
      		});
      	}
          
          
      }
	  function DistanceCalc(){
		  var dates = {
				    convert:function(d) {
				        // Converts the date in d to a date-object. The input can be:
				        //   a date object: returned without modification
				        //  an array      : Interpreted as [year,month,day]. NOTE: month is 0-11.
				        //   a number     : Interpreted as number of milliseconds
				        //                  since 1 Jan 1970 (a timestamp) 
				        //   a string     : Any format supported by the javascript engine, like
				        //                  "YYYY/MM/DD", "MM/DD/YYYY", "Jan 31 2009" etc.
				        //  an object     : Interpreted as an object with year, month and date
				        //                  attributes.  **NOTE** month is 0-11.
				        return (
				            d.constructor === Date ? d :
				            d.constructor === Array ? new Date(d[0],d[1],d[2]) :
				            d.constructor === Number ? new Date(d) :
				            d.constructor === String ? new Date(d) :
				            typeof d === "object" ? new Date(d.year,d.month,d.date) :
				            NaN
				        );
				    },
				    compare:function(a,b) {
				        // Compare two dates (could be of any type supported by the convert
				        // function above) and returns:
				        //  -1 : if a &lt; b
				        //   0 : if a = b
				        //   1 : if a &gt; b
				        // NaN : if a or b is an illegal date
				        // NOTE: The code inside isFinite does an assignment (=).
				        return (
				            isFinite(a=this.convert(a).valueOf()) &amp;&amp;
				            isFinite(b=this.convert(b).valueOf()) ?
				            (a&gt;b)-(a&lt;b) :
				            NaN
				        );
				    },
				    
				}
		  var originA = "#{routeController.route.beginpunt}";
		  var destA = "#{routeController.route.eindpunt}";
		  var destT = document.getElementById('requestform:pleaseGodWork').value;
		  var originT = destT;
		 
		  var destinationIcon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&amp;chld=D|FF0000|000000';
	 	 var originIcon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&amp;chld=O|FFFF00|000000';
		  
		 
		  var service = new google.maps.DistanceMatrixService;
		  service.getDistanceMatrix({
			    origins: [originA, originT],
			    destinations: [destA, destT],
			    travelMode: 'DRIVING',
			    unitSystem: google.maps.UnitSystem.METRIC,
			    avoidHighways: false,
			    avoidTolls: false
			  }, function(response, status) {
			    if (status !== 'OK') {
			      alert('Error was: ' + status);
			    } else {
			      var originList = response.originAddresses;
			      var destinationList = response.destinationAddresses;
			    /*   var outputDiv = document.getElementById('output');
			      outputDiv.innerHTML = '';
			      deleteMarkers(markersArray);
 */
				

				var totalDuration = 0;
				/* for (var i = 0; i &lt; originList.length; i++) {
				  var results = response.rows[i].elements;
				  geocoder.geocode({'address': originList[i]},
				      showGeocodedAddressOnMap(false));
				  for (var j = 0; j &lt; results.length; j++) {
				    geocoder.geocode({'address': destinationList[j]},
				        showGeocodedAddressOnMap(true));
				    outputDiv.innerHTML += originList[i] + ' to ' + destinationList[j] +
				        ': ' + results[j].distance.text + ' in ' +
				        results[j].duration.text + '<br />';
				  }
				} */
				var resultAT = response.rows[0].elements[1].duration.value;

				console.log(resultAT);
				var resultTD = response.rows[1].elements[0].duration.value;
				console.log(resultTD);
				totalDuration = resultAT + resultTD;
				console.log("Totale tijd in sec voor de route met omweg: "
						+ totalDuration);
				var totDinmin = Math.ceil(totalDuration/60);
				console.log("In minuten: " + totDinmin);
				var DateTimeBegin = new Date("#{routeController.route.vertrektijd}");
				console.log("timestamp Begintijd");
				console.log(DateTimeBegin);
				var DateTimeEind = new Date("#{routeController.route.eindtijd}");
				console.log("timestamp aankomsttijd");
				console.log(DateTimeEind);
				var newDateobj = new Date(DateTimeBegin.getTime() + totDinmin*60000);
				console.log("Begintijd + minuten met omweg");
				console.log(newDateobj);
				var test = dates.compare(DateTimeEind,newDateobj);
				console.log(test);
				if(test == 1){
					var VertrekP = new Date(DateTimeBegin.getTime() + (Math.ceil(resultAT/60))*60000);
					console.log(VertrekP);
					document.getElementById('requestform:Verzoek').style.display= 'inline';
					document.getElementById('requestform:VertrekTijd').value = VertrekP;
				} else {
					document.getElementById('requestform:Verzoek').style.display= 'none';
				}
				
			}
		});

	}
	function calculateAndDisplayRoute(directionsService, directionsRenderer) {

		var waypts = [];
		/* var checkboxArray = document.getElementById('waypoints');
		for (var i = 0; i &lt; checkboxArray.length; i++) {
		  if (checkboxArray.options[i].selected) {
		    waypts.push({
		      location: checkboxArray[i].value,
		      stopover: true
		    });
		  }
		} */

		directionsService.route({
			origin : "#{routeController.route.beginpunt}",
			destination : "#{routeController.route.eindpunt}",
			waypoints : waypts,
			optimizeWaypoints : true,
			travelMode : 'DRIVING'
		}, function(response, status) {
			if (status === 'OK') {
				directionsRenderer.setDirections(response);
				var route = response.routes[0];
				/*var summaryPanel = document.getElementById('directions-panel');
				summaryPanel.innerHTML = '';
				// For each route, display summary information.
				 for (var i = 0; i &lt; route.legs.length; i++) {
				  var routeSegment = i + 1;
				  summaryPanel.innerHTML += '<b>Route Segment: ' + routeSegment +
				      '</b><br />';
				  summaryPanel.innerHTML += route.legs[i].start_address + ' to ';
				  summaryPanel.innerHTML += route.legs[i].end_address + '<br />';
				  summaryPanel.innerHTML += route.legs[i].distance.text + '<br /><br />';
				} */
			} else {
				window.alert('Directions request failed due to ' + status);
			}
		});
	}
	function PlaceAutocompleteSearch() {

		var options = {
			types : [ 'address' ]
		};
		var componentForm = {
			street_number : 'short_name',
			route : 'long_name',
			locality : 'long_name',
			administrative_area_level_1 : 'short_name',
			country : 'long_name',
			postal_code : 'short_name'
		};
		var input = document.getElementById('vertrekAdress');
		var autocomplete = new google.maps.places.Autocomplete(input, options);
		var place = autocomplete.getPlace();
		autocomplete.addListener('place_changed', fillInAddress);
		/*   document.getElementById('viewRoute:pleaseGodWork').value = place.formatted_address; */
		console.log(document.getElementById('requestform:pleaseGodWork').value)

		function fillInAddress() {
			// Get the place details from the autocomplete object.
			var place = autocomplete.getPlace();
			console.log(place);

			document.getElementById('requestform:pleaseGodWork').value = place.formatted_address;
			
		}

	}
	
	
</script>

</h:body>
</html>
